import numpy as np

def lu_decomposition(A):
    """
    LU-разложение матрицы A на нижнюю (L) и верхнюю (U) треугольные матрицы
    A = L * U, где L - нижняя треугольная с единицами на диагонали
    """
    n = len(A)
    L = np.zeros((n, n))
    U = np.zeros((n, n))
    
    for i in range(n):
        # Верхняя треугольная матрица U
        for k in range(i, n):
            sum_ = sum(L[i][j] * U[j][k] for j in range(i))
            U[i][k] = A[i][k] - sum_
        
        # Нижняя треугольная матрица L
        L[i][i] = 1  # Диагональные элементы = 1
        for k in range(i + 1, n):
            sum_ = sum(L[k][j] * U[j][i] for j in range(i))
            L[k][i] = (A[k][i] - sum_) / U[i][i]
    
    return L, U

def solve_triangular(L, b, lower=True):
    """
    Решение треугольной системы уравнений
    lower=True: L * x = b (нижняя треугольная)
    lower=False: U * x = b (верхняя треугольная)
    """
    n = len(L)
    x = np.zeros(n)
    
    if lower:  # Прямая подстановка для L
        for i in range(n):
            x[i] = (b[i] - sum(L[i][j] * x[j] for j in range(i))) / L[i][i]
    else:  # Обратная подстановка для U
        for i in range(n - 1, -1, -1):
            x[i] = (b[i] - sum(L[i][j] * x[j] for j in range(i + 1, n))) / L[i][i]
    
    return x

def inverse_matrix_lu(A):
    """
    Обращение матрицы с помощью LU-разложения
    """
    n = len(A)
    
    # 1. Выполняем LU-разложение
    L, U = lu_decomposition(A)
    
    # 2. Создаем единичную матрицу
    I = np.eye(n)
    
    # 3. Решаем n систем уравнений: A * X[:, i] = I[:, i]
    inv_A = np.zeros((n, n))
    
    for i in range(n):
        # Решаем L * y = I[:, i] (прямая подстановка)
        y = solve_triangular(L, I[:, i], lower=True)
        
        # Решаем U * x = y (обратная подстановка)
        x = solve_triangular(U, y, lower=False)
        
        inv_A[:, i] = x
    
    return inv_A

# Пример использования
def example1():
    print("Пример 1: Обращение матрицы 3x3")
    print("=" * 50)
    
    A = np.array([
        [4, 3, 1],
        [0, 1, -3],
        [4, 0, 2]
    ], dtype=float)
    
    print("Исходная матрица A:")
    print(A)
    print()
    
    # LU-разложение
    L, U = lu_decomposition(A)
    print("Матрица L (нижняя треугольная):")
    print(L)
    print("\nМатрица U (верхняя треугольная):")
    print(U)
    print("\nПроверка: L * U =")
    print(np.dot(L, U))
    print()
    
    # Обращение матрицы
    A_inv = inverse_matrix_lu(A)
    print("Обратная матрица A⁻¹:")
    print(A_inv)
    print()
    
    # Проверка: A * A⁻¹ должно быть единичной матрицей
    print("Проверка: A * A⁻¹ =")
    print(np.dot(A, A_inv))
    print("\nНорма разности с единичной матрицей:", np.linalg.norm(np.dot(A, A_inv) - np.eye(3)))

# Запуск примера
example1()
